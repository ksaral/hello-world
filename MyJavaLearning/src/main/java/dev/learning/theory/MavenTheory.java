package dev.learning.theory;

public class MavenTheory {

	/**
	 * a. Follows a plug-inâ€“based architecture.
	 * 
	 * b. Easy to augment and customize its functionality.
	 * 
	 * c. Easy to create your own plug-ins.
	 * 
	 * d. Integrate tasks and workflows that are specific to your organization.
	 * 
	 * e. Uniform Build Abstraction.
	 * 
	 * Maven archetypes are predefined project templates that can be used to
	 * generate new projects. Archetypes is also a valuable tool for bundling
	 * best practices and common assets that you will need in each of your
	 * projects.
	 * 
	 * Example: Consider a team that works heavily on Spring framework-based web
	 * applications. All Spring-based web projects share common dependencies and
	 * require a set of Spring configuration files. It is also highly possible
	 * that all of these web projects have similar Log4j/Logback configuration
	 * files, CSS/Images, and Apache Tile layouts or SiteMesh decorators. Maven
	 * lets this team bundle these common assets into an archetype. When new
	 * projects get created using this archetype, they will automatically have
	 * the common assets included. No more copy and pastes or drag and drops
	 * required.
	 * 
	 */

	/**
	 * Convention Over Configuration Convention over configuration (CoC) or
	 * coding by convention is one of the key tenants of Maven. CoC emphasizes
	 * sensible defaults, thereby reducing the number of decisions to be made.
	 * It saves time and also results in a simpler end product, as the amount of
	 * configuration required is drastically reduced.
	 */

	/**
	 * Maven Alternatives
	 * 
	 * a. Ant + Ivy: Ant is Java based, and it uses Extensible Markup Language
	 * (XML) for its configuration. The default configuration file for Ant is
	 * the build.xml file. Apache Ivy (http://ant.apache.org/ivy/) provides
	 * automated dependency management, making Ant more joyful to use.
	 * 
	 * b. Gradle: uses a Groovy-based Domain Specific Language (DSL). It
	 * provides the flexibility of Ant, and it uses the same notion of tasks. It
	 * also follows Maven's conventions and dependency management style.
	 */

	/**
	 * MAVEN environment variables:
	 * 
	 * M2_HOME = <maven installation directory>
	 * 
	 * Path = %M2_HOME%/bin;.........<rest of path>
	 * 
	 * MAVEN_OPTS = To address OutOfMemory errors by increasing JVM heap size
	 * 
	 * Open command prompt, and check mvn -v to confirm that installation is
	 * successful.
	 */

	/**
	 * User-specific configuration
	 * 
	 * Is provided in a settings.xml file located in the
	 * C:\Users\<<user_name>>\.m2 folder.
	 */

	/**
	 * Maven requires an Internet connection to download plug-ins and
	 * dependencies. The default remote repository with which Maven interacts is
	 * called Maven Central, and it is located at repo.maven.apache.org and
	 * uk.maven.org. Maven places the downloaded artifacts in the local
	 * repository.
	 */

	/**
	 * GAV coordinates --> uniquely identify a maven dependency.
	 * 
	 * groupId: Identifier of the organization or group that is responsible for
	 * this project. Examples include org.hibernate, log4j, and
	 * org.springframework.boot.
	 * 
	 * artifactId: Identifier of the artifact being generated by the project.
	 * This must be unique among the projects using the same groupId. Examples
	 * include hibernate-tools, log4j, spring-core, and so on.
	 * 
	 * version: Indicates the version number of the project. Examples include
	 * 1.0.0, 2.3.1-SNAPSHOT, and 4.3.6.Final.
	 * 
	 * type: Indicates the packing of the generated artifact. Examples include
	 * JAR, WAR, and EAR.
	 */

	/**
	 * Transitive Dependencies
	 * 
	 * Dependencies declared in your project's pom.xml file often have their own
	 * dependencies. Such dependencies are called transitive dependencies.
	 * 
	 * Maven uses a technique known as dependency mediation to resolve version
	 * conflicts. Simply stated, dependency mediation allows Maven to pull the
	 * dependency that is closest to the project in the tree.
	 */

	/**
	 * Dependency Scope
	 * 
	 * Maven provides the following six scopes:
	 * 
	 * compile: Dependencies with the compile scope are available in the class
	 * path in all phases on a project build, test, and run. This is the default
	 * scope.
	 * 
	 * provided: Dependencies with the provided scope are available in the class
	 * path during the build and test phases. They don't get bundled within the
	 * generated artifact. Examples of dependencies that use this scope include
	 * Servlet api, JSP api, and so on.
	 * 
	 * runtime: Dependencies with the runtime scope are not available in the
	 * class path during the build phase. Instead they get bundled in the
	 * generated artifact and are available during runtime.
	 * 
	 * test: Dependencies with the test scope are available during the test
	 * phase. JUnit and TestNG are good examples of dependencies with the test
	 * scope.
	 * 
	 * system: Dependencies with the system scope are similar to dependencies
	 * with the provided scope, except that these dependencies are not retrieved
	 * from the repository. Instead, a hard-coded path to the file system is
	 * specified from which the dependencies are used.
	 * 
	 * import: The import scope is applicable for .pom file dependencies only.
	 * It allows you to include dependency management information from a remote
	 * .pom file. The import scope is available only in Maven 2.0.9 or later.
	 */

	/**
	 * Manual Dependency Installation
	 * 
	 * Maven provides a handy way of installing an archive into your local
	 * repository with the install plug-in.
	 * 
	 * Example: C:\apress\gswm-book\chapter3>mvn install:install-file
	 * -DgroupId=com.apress. gswmbook -DartifactId=test -Dversion=1.0.0
	 * -Dfile=C:\apress\gswm-book\chapter3\ test.jar -Dpackaging=jar
	 * -DgeneratePom=true
	 */

}
